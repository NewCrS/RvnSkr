<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ki·ªÉm Tra C·ª≠ Ch·ªâ B√†n Tay Tr√°i (GitHub Pages)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script> 
    
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }
        #video-container {
            position: relative;
            width: 90%;
            max-width: 640px;
            margin-bottom: 20px;
            background-color: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        #video-feed, #canvas-output {
            width: 100%;
            height: auto;
            display: block;
            transform: scaleX(-1); /* L·∫≠t ngang ƒë·ªÉ t·∫°o c·∫£m gi√°c nh∆∞ g∆∞∆°ng */
        }
        #canvas-output {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #overlay-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.3em;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 8px;
            width: 90%;
            box-sizing: border-box;
            transition: all 0.5s ease;
            z-index: 10;
        }
        #status-message {
             margin-top: 10px;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.1em;
            width: 90%;
            max-width: 640px;
            text-align: center;
        }
        .status-initial { background-color: #3f51b5; color: white; }
        .status-processing { background-color: #ff9800; color: #333; }
        .status-success { background-color: #4CAF50; color: white; animation: pulse 1s infinite; }
        .status-error { background-color: #f44336; color: white; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="video-feed" autoplay playsinline></video>
        <canvas id="canvas-output"></canvas> 
        <div id="overlay-text">
            ‚åõ ƒêang t·∫£i m√¥ h√¨nh...
        </div>
    </div>

    <div id="status-message" class="status-initial">
        ƒêang ch·ªù quy·ªÅn truy c·∫≠p Camera v√† t·∫£i m√¥ h√¨nh H·ªçc m√°y. (Y√™u c·∫ßu HTTPS ho·∫∑c Localhost)
    </div>

    <script>
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('canvas-output');
        const ctx = canvas.getContext('2d');
        const overlayText = document.getElementById('overlay-text');
        const statusMessage = document.getElementById('status-message');
        
        let detector;
        let animationFrameId;
        window.isGestureSuccessful = false;

        // ƒêi·ªÉm m·ªëc quan tr·ªçng (theo MediaPipe)
        const FINGER_LANDMARKS = {
            WRIST: 0,
            THUMB_CMC: 1, THUMB_MCP: 2, THUMB_IP: 3, THUMB_TIP: 4,
            INDEX_FINGER_MCP: 5, INDEX_FINGER_PIP: 6, INDEX_FINGER_DIP: 7, INDEX_FINGER_TIP: 8,
            MIDDLE_FINGER_MCP: 9, MIDDLE_FINGER_PIP: 10, MIDDLE_FINGER_DIP: 11, MIDDLE_FINGER_TIP: 12,
            RING_FINGER_MCP: 13, RING_FINGER_PIP: 14, RING_FINGER_DIP: 15, RING_FINGER_TIP: 16,
            PINKY_MCP: 17, PINKY_FINGER_PIP: 18, PINKY_FINGER_DIP: 19, PINKY_FINGER_TIP: 20
        };

        // ƒê·ªãnh nghƒ©a c√°c c·∫∑p ƒëi·ªÉm m·ªëc (b·∫Øt ƒë·∫ßu, k·∫øt th√∫c) cho t·ª´ng ng√≥n tay v√† kh·ªõp n·ªëi c·ªï tay
        const FINGER_SEGMENTS = {
            WRIST_PALM: [[0, 1], [0, 5], [0, 17], [5, 9], [9, 13], [13, 17]],
            THUMB: [[1, 2], [2, 3], [3, 4]],
            INDEX: [[5, 6], [6, 7], [7, 8]],
            MIDDLE: [[9, 10], [10, 11], [11, 12]],
            RING: [[13, 14], [14, 15], [15, 16]],
            PINKY: [[17, 18], [18, 19], [19, 20]]
        };
        
        // H√†m gi√∫p t√≠nh kho·∫£ng c√°ch gi·ªØa hai ƒëi·ªÉm trong kh√¥ng gian 3D
        function distance(p1, p2) {
            return Math.sqrt(
                Math.pow(p1.x - p2.x, 2) + 
                Math.pow(p1.y - p2.y, 2) + 
                Math.pow(p1.z - p2.z, 2)
            );
        }

        async function setupDetector() {
            try {
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'mediapipe',
                    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915', 
                    modelType: 'full'
                };
                detector = await handPoseDetection.createDetector(model, detectorConfig);

                overlayText.innerHTML = "‚úÖ M√¥ h√¨nh ƒë√£ t·∫£i. ƒêang xin quy·ªÅn Camera...";
                statusMessage.textContent = "‚úÖ M√¥ h√¨nh ƒë√£ t·∫£i. Vui l√≤ng c·∫•p quy·ªÅn Camera.";
                statusMessage.classList.remove('status-initial');
                statusMessage.classList.add('status-processing');
                
                await setupCamera();

            } catch (error) {
                console.error("L·ªói khi t·∫£i m√¥ h√¨nh ho·∫∑c camera:", error);
                statusMessage.textContent = `‚ùå L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh ho·∫∑c camera. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† quy·ªÅn camera.`;
                statusMessage.classList.remove('status-initial', 'status-processing');
                statusMessage.classList.add('status-error');
                overlayText.innerHTML = "‚ùå L·ªñI KH·ªûI T·∫†O";
            }
        }

        async function setupCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        startDetectionLoop();
                        resolve(true);
                    };
                });
            } else {
                throw new Error("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ MediaDevices API.");
            }
        }

        /**
         * 2. V√≤ng l·∫∑p Nh·∫≠n d·∫°ng C·ª≠ ch·ªâ
         */
        function startDetectionLoop() {
            const detect = async () => {
                const hands = await detector.estimateHands(video, { flipHorizontal: false }); 

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (hands.length > 0) {
                    const hand = hands[0];
                    
                    const getZCoord = (id) => {
                        if (hand.keypoints3D && hand.keypoints3D[id]) {
                            return hand.keypoints3D[id].z * canvas.width;
                        }
                        return 0;
                    };

                    const landmarks = hand.keypoints.map((p, index) => {
                        return {
                            x: p.x * (canvas.width / video.videoWidth), 
                            y: p.y * (canvas.height / video.videoHeight), 
                            z: getZCoord(index), 
                            name: p.name
                        };
                    });
                    
                    // 3. TH·ª∞C HI·ªÜN LOGIC NH·∫¨N D·∫†NG C·ª¨ CH·ªà V√Ä L·∫§Y TR·∫†NG TH√ÅI T·ª™NG NG√ìN
                    const fingerStatus = getFingerStatus(hand, landmarks);
                    const isCurrentGestureSuccessful = fingerStatus.allFingersCorrect;
                    
                    if (isCurrentGestureSuccessful && !window.isGestureSuccessful) {
                        handleSuccess();
                    } 
                    
                    // LU√îN V·∫º HITBOX V√Ä CHUY·ªÇN M√ÄU THEO TR·∫†NG TH√ÅI T·ª™NG NG√ìN
                    drawHandLandmarks(landmarks, fingerStatus);

                    // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i
                    if (!window.isGestureSuccessful) {
                         overlayText.innerHTML = `‚úã`;
                    } else {
                         overlayText.innerHTML = "QU√âT TH√ÄNH C√îNG!";
                         statusMessage.textContent = " Nh·∫≠n d·∫°ng th√†nh c√¥ng! Ch√†o m·ª´ng ƒë·∫øn RvnSkr";
                    }

                } else {
                    if (!window.isGestureSuccessful) {
                         overlayText.innerHTML = "üëã";
                    }
                }

                animationFrameId = requestAnimationFrame(detect);
            };
            detect();
        }

        /**
         * 3. Logic Nh·∫≠n d·∫°ng C·ª≠ ch·ªâ M·ª•c ti√™u - Tr·∫£ v·ªÅ tr·∫°ng th√°i t·ª´ng ng√≥n
         */
        function getFingerStatus(hand, landmarks) {
            
            // 3.1. KI·ªÇM TRA B√ÄN TAY TR√ÅI (Handedness)
            if (hand.handedness !== 'Right') {
                return { isCorrectHand: false, allFingersCorrect: false }; 
            }

            // 3.2. H√ÄM KI·ªÇM TRA TR·∫†NG TH√ÅI
            
            const checkFingerStraight = (tip_index, pip_index, mcp_index) => {
                const tip = landmarks[tip_index];
                const mcp = landmarks[mcp_index];
                const pip = landmarks[pip_index];
                const dist_tip_mcp = distance(tip, mcp);
                const dist_pip_mcp = distance(pip, mcp);
                return (dist_tip_mcp / dist_pip_mcp) > 1.25; 
            };

            const checkFingerFolded = (tip_index, dip_index, pip_index) => {
                const dist_tip_dip = distance(landmarks[tip_index], landmarks[dip_index]);
                return dist_tip_dip < 40; 
            };

            const isThumbUp = distance(landmarks[FINGER_LANDMARKS.THUMB_TIP], landmarks[FINGER_LANDMARKS.THUMB_MCP]) > 65; 
            const isIndexUp = checkFingerStraight(FINGER_LANDMARKS.INDEX_FINGER_TIP, FINGER_LANDMARKS.INDEX_FINGER_PIP, FINGER_LANDMARKS.INDEX_FINGER_MCP);
            const isMiddleUp = checkFingerStraight(FINGER_LANDMARKS.MIDDLE_FINGER_TIP, FINGER_LANDMARKS.MIDDLE_FINGER_PIP, FINGER_LANDMARKS.MIDDLE_FINGER_MCP);
            const isRingFolded = checkFingerFolded(FINGER_LANDMARKS.RING_FINGER_TIP, FINGER_LANDMARKS.RING_FINGER_DIP, FINGER_LANDMARKS.RING_FINGER_PIP);
            const isPinkyFolded = checkFingerFolded(FINGER_LANDMARKS.PINKY_FINGER_TIP, FINGER_LANDMARKS.PINKY_FINGER_DIP, FINGER_LANDMARKS.PINKY_FINGER_PIP);
            
            const allFingersCorrect = isThumbUp && isIndexUp && isMiddleUp && isRingFolded && isPinkyFolded;

            return {
                isCorrectHand: true,
                allFingersCorrect: allFingersCorrect,
                thumb: isThumbUp,
                index: isIndexUp,
                middle: isMiddleUp,
                ring: isRingFolded,
                pinky: isPinkyFolded
            };
        }

        function handleSuccess() {
            window.isGestureSuccessful = true;
            
            overlayText.innerHTML = "QU√âT TH√ÄNH C√îNG!";
            overlayText.style.backgroundColor = 'rgba(76, 175, 80, 0.9)';
            
            statusMessage.textContent = " Nh·∫≠n d·∫°ng th√†nh c√¥ng! Ch√†o m·ª´ng ƒë·∫øn RvnSkr";
            statusMessage.classList.remove('status-processing');
            statusMessage.classList.add('status-success');
        }

        /**
         * H√†m v·∫Ω hitbox, nh·∫≠n ƒë·ªëi t∆∞·ª£ng tr·∫°ng th√°i ng√≥n tay ƒë·ªÉ ƒë·ªïi m√†u.
         */
        function drawHandLandmarks(landmarks, fingerStatus) {
            
            // M√†u m·∫∑c ƒë·ªãnh
            const DEFAULT_COLOR = '#FF4500'; // ƒê·ªè cam
            // M√†u khi ƒë√∫ng
            const SUCCESS_COLOR = '#4CAF50'; // Xanh l√°
            // M√†u n·ªÅn/l√≤ng b√†n tay
            const PALM_COLOR = '#808080'; // X√°m

            // 1. V·∫Ω c√°c ƒëo·∫°n k·∫øt n·ªëi (x∆∞∆°ng)
            const segments = [
                // Ng√≥n c√°i
                { indices: FINGER_SEGMENTS.THUMB, color: fingerStatus.thumb ? SUCCESS_COLOR : DEFAULT_COLOR },
                // Ng√≥n tr·ªè
                { indices: FINGER_SEGMENTS.INDEX, color: fingerStatus.index ? SUCCESS_COLOR : DEFAULT_COLOR },
                // Ng√≥n gi·ªØa
                { indices: FINGER_SEGMENTS.MIDDLE, color: fingerStatus.middle ? SUCCESS_COLOR : DEFAULT_COLOR },
                // Ng√≥n √°p √∫t
                { indices: FINGER_SEGMENTS.RING, color: fingerStatus.ring ? SUCCESS_COLOR : DEFAULT_COLOR },
                // Ng√≥n √∫t
                { indices: FINGER_SEGMENTS.PINKY, color: fingerStatus.pinky ? SUCCESS_COLOR : DEFAULT_COLOR },
                // L√≤ng b√†n tay/C·ªï tay (lu√¥n gi·ªØ m√†u x√°m)
                { indices: FINGER_SEGMENTS.WRIST_PALM, color: PALM_COLOR }
            ];

            ctx.lineWidth = 3; 

            segments.forEach(segment => {
                ctx.strokeStyle = segment.color;
                segment.indices.forEach(([start, end]) => {
                    const p1 = landmarks[start];
                    const p2 = landmarks[end];
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });
            });

            // 2. V·∫Ω c√°c ƒëi·ªÉm m·ªëc (joints)
            landmarks.forEach((p, index) => {
                let color;
                
                // X√°c ƒë·ªãnh m√†u cho ƒëi·ªÉm m·ªëc d·ª±a tr√™n ng√≥n tay m√† n√≥ thu·ªôc v·ªÅ
                if ([1, 2, 3, 4].includes(index)) { // Ng√≥n c√°i
                    color = fingerStatus.thumb ? SUCCESS_COLOR : DEFAULT_COLOR;
                } else if ([5, 6, 7, 8].includes(index)) { // Ng√≥n tr·ªè
                    color = fingerStatus.index ? SUCCESS_COLOR : DEFAULT_COLOR;
                } else if ([9, 10, 11, 12].includes(index)) { // Ng√≥n gi·ªØa
                    color = fingerStatus.middle ? SUCCESS_COLOR : DEFAULT_COLOR;
                } else if ([13, 14, 15, 16].includes(index)) { // Ng√≥n √°p √∫t
                    color = fingerStatus.ring ? SUCCESS_COLOR : DEFAULT_COLOR;
                } else if ([17, 18, 19, 20].includes(index)) { // Ng√≥n √∫t
                    color = fingerStatus.pinky ? SUCCESS_COLOR : DEFAULT_COLOR;
                } else { // C·ªï tay, CMC (0) v√† MCPs (5, 9, 13, 17)
                    color = PALM_COLOR;
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); 
                ctx.fill();
            });
        }

        // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
        setupDetector();
        
    </script>
</body>
</html>
