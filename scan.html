</html>
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ki·ªÉm Tra C·ª≠ Ch·ªâ Ba Ng√≥n Du·ªói, Hai Ng√≥n G·∫≠p (T·ªëi ∆Øu Cu·ªëi)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script> 
    
    <style>
        /* ... (CSS kh√¥ng ƒë·ªïi) ... */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }
        #video-container {
            position: relative;
            width: 90%;
            max-width: 640px;
            margin-bottom: 20px;
            background-color: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        #video-feed, #canvas-output {
            width: 100%;
            height: auto;
            display: block;
            transform: scaleX(-1); /* L·∫≠t ngang ƒë·ªÉ t·∫°o c·∫£m gi√°c nh∆∞ g∆∞∆°ng */
        }
        #canvas-output {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #overlay-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.3em;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 8px;
            width: 90%;
            box-sizing: border-box;
            transition: all 0.5s ease;
            z-index: 10;
        }
        #status-message {
             margin-top: 10px;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.1em;
            width: 90%;
            max-width: 640px;
            text-align: center;
        }
        .status-initial { background-color: #3f51b5; color: white; }
        .status-processing { background-color: #ff9800; color: #333; }
        .status-success { background-color: #4CAF50; color: white; animation: pulse 1s infinite; }
        .status-error { background-color: #f44336; color: white; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="video-feed" autoplay playsinline></video>
        <canvas id="canvas-output"></canvas> 
        <div id="overlay-text">
            ‚åõ ƒêang t·∫£i m√¥ h√¨nh...
        </div>
    </div>

    <div id="status-message" class="status-initial">
        ƒêang ch·ªù quy·ªÅn truy c·∫≠p Camera v√† t·∫£i m√¥ h√¨nh H·ªçc m√°y. (Y√™u c·∫ßu HTTPS ho·∫∑c Localhost)
    </div>

    <script>
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('canvas-output');
        const ctx = canvas.getContext('2d');
        const overlayText = document.getElementById('overlay-text');
        const statusMessage = document.getElementById('status-message');
        
        let detector;
        let animationFrameId;
        window.isGestureSuccessful = false;

        // ƒêi·ªÉm m·ªëc quan tr·ªçng (theo MediaPipe)
        const FINGER_LANDMARKS = {
            WRIST: 0,
            THUMB_CMC: 1, THUMB_MCP: 2, THUMB_IP: 3, THUMB_TIP: 4,
            INDEX_FINGER_MCP: 5, INDEX_FINGER_PIP: 6, INDEX_FINGER_DIP: 7, INDEX_FINGER_TIP: 8,
            MIDDLE_FINGER_MCP: 9, MIDDLE_FINGER_PIP: 10, MIDDLE_FINGER_DIP: 11, MIDDLE_FINGER_TIP: 12,
            RING_FINGER_MCP: 13, RING_FINGER_PIP: 14, RING_FINGER_DIP: 15, RING_FINGER_TIP: 16,
            PINKY_MCP: 17, PINKY_FINGER_PIP: 18, PINKY_FINGER_DIP: 19, PINKY_FINGER_TIP: 20
        };

        // ƒê·ªãnh nghƒ©a c√°c c·∫∑p ƒëi·ªÉm m·ªëc (b·∫Øt ƒë·∫ßu, k·∫øt th√∫c) cho t·ª´ng ng√≥n tay v√† kh·ªõp n·ªëi c·ªï tay
        const FINGER_SEGMENTS = {
            WRIST_PALM: [[0, 1], [0, 5], [0, 17], [5, 9], [9, 13], [13, 17]],
            THUMB: [[1, 2], [2, 3], [3, 4]],
            INDEX: [[5, 6], [6, 7], [7, 8]],
            MIDDLE: [[9, 10], [10, 11], [11, 12]],
            RING: [[13, 14], [14, 15], [15, 16]],
            PINKY: [[17, 18], [18, 19], [19, 20]]
        };
        
        // H√†m gi√∫p t√≠nh kho·∫£ng c√°ch gi·ªØa hai ƒëi·ªÉm trong kh√¥ng gian 3D
        function distance(p1, p2) {
            return Math.sqrt(
                Math.pow(p1.x - p2.x, 2) + 
                Math.pow(p1.y - p2.y, 2) + 
                Math.pow(p1.z - p2.z, 2)
            );
        }

        async function setupDetector() {
            // ... (setupDetector kh√¥ng ƒë·ªïi)
            try {
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'mediapipe',
                    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915', 
                    modelType: 'full'
                };
                detector = await handPoseDetection.createDetector(model, detectorConfig);

                overlayText.innerHTML = "‚úÖ M√¥ h√¨nh ƒë√£ t·∫£i. ƒêang xin quy·ªÅn Camera...";
                statusMessage.textContent = "‚úÖ M√¥ h√¨nh ƒë√£ t·∫£i. Vui l√≤ng c·∫•p quy·ªÅn Camera.";
                statusMessage.classList.remove('status-initial');
                statusMessage.classList.add('status-processing');
                
                await setupCamera();

            } catch (error) {
                console.error("L·ªói khi t·∫£i m√¥ h√¨nh ho·∫∑c camera:", error);
                statusMessage.textContent = `‚ùå L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh ho·∫∑c camera. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† quy·ªÅn camera.`;
                statusMessage.classList.remove('status-initial', 'status-processing');
                statusMessage.classList.add('status-error');
                overlayText.innerHTML = "‚ùå L·ªñI KH·ªûI T·∫†O";
            }
        }

        async function setupCamera() {
            // ... (setupCamera kh√¥ng ƒë·ªïi)
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        startDetectionLoop();
                        resolve(true);
                    };
                });
            } else {
                throw new Error("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ MediaDevices API.");
            }
        }

        function startDetectionLoop() {
            // ... (startDetectionLoop kh√¥ng ƒë·ªïi)
            const detect = async () => {
                const hands = await detector.estimateHands(video, { flipHorizontal: false }); 

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (hands.length > 0) {
                    const hand = hands[0];
                    
                    const getZCoord = (id) => {
                        if (hand.keypoints3D && hand.keypoints3D[id]) {
                            return hand.keypoints3D[id].z * canvas.width;
                        }
                        return 0;
                    };

                    const landmarks = hand.keypoints.map((p, index) => {
                        return {
                            x: p.x * (canvas.width / video.videoWidth), 
                            y: p.y * (canvas.height / video.videoHeight), 
                            z: getZCoord(index), 
                            name: p.name
                        };
                    });
                    
                    // 3. TH·ª∞C HI·ªÜN LOGIC NH·∫¨N D·∫†NG C·ª¨ CH·ªà V√Ä L·∫§Y TR·∫†NG TH√ÅI T·ª™NG NG√ìN
                    const fingerStatus = getFingerStatus(hand, landmarks);
                    const isCurrentGestureSuccessful = fingerStatus.allFingersCorrect;
                    
                    if (isCurrentGestureSuccessful && !window.isGestureSuccessful) {
                        handleSuccess();
                    } 
                    
                    // LU√îN V·∫º HITBOX V√Ä CHUY·ªÇN M√ÄU THEO TR·∫†NG TH√ÅI T·ª™NG NG√ìN
                    drawHandLandmarks(landmarks, fingerStatus);

                    // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i
                    if (!window.isGestureSuccessful) {
                         overlayText.innerHTML = `‚úã`;
                    } else {
                         overlayText.innerHTML = "QU√âT TH√ÄNH C√îNG!";
                         statusMessage.textContent = " Nh·∫≠n d·∫°ng th√†nh c√¥ng! Ch√†o m·ª´ng ƒë·∫øn RvnSkr";
                    }

                } else {
                    if (!window.isGestureSuccessful) {
                         overlayText.innerHTML = "üëã";
                    }
                }

                animationFrameId = requestAnimationFrame(detect);
            };
            detect();
        }

        /**
         * 3. Logic Nh·∫≠n d·∫°ng C·ª≠ ch·ªâ M·ª•c ti√™u - Tr·∫£ v·ªÅ tr·∫°ng th√°i t·ª´ng ng√≥n
         * Y√™u c·∫ßu M·ªöI: Tr·ªè/Gi·ªØa/C√°i Du·ªói (kh√¥ng c·∫ßn kh√©p s√°t); √Åp √öt/√öt G·∫≠p (ng∆∞·ª°ng n·ªõi l·ªèng).
         */
        function getFingerStatus(hand, landmarks) {
            
            // 3.1. KI·ªÇM TRA B√ÄN TAY PH·∫¢I (Handedness)
            if (hand.handedness !== 'Right') {
                return { isCorrectHand: false, allFingersCorrect: false }; 
            }

            // 3.2. H√ÄM KI·ªÇM TRA TR·∫†NG TH√ÅI C∆† B·∫¢N
            
            const checkFingerStraight = (tip_index, pip_index, mcp_index) => {
                const tip = landmarks[tip_index];
                const mcp = landmarks[mcp_index];
                const pip = landmarks[pip_index];
                const dist_tip_mcp = distance(tip, mcp);
                const dist_pip_mcp = distance(pip, mcp);
                // Ng√≥n du·ªói th·∫≥ng (Gi·ªØ nguy√™n ng∆∞·ª°ng 1.25 - ƒë√¢y l√† ng∆∞·ª°ng t·ª∑ l·ªá ƒë√°ng tin c·∫≠y)
                return (dist_tip_mcp / dist_pip_mcp) > 1.25; 
            };

            const checkFingerFolded = (tip_index, dip_index, pip_index) => {
                const dist_tip_dip = distance(landmarks[tip_index], landmarks[dip_index]);
                // ƒêI·ªÄU CH·ªàNH: N·ªõi l·ªèng ng∆∞·ª°ng g·∫≠p t·ª´ 20 l√™n 30 (ho·∫∑c 35). Ch·∫•p nh·∫≠n ƒë·ªô g·∫≠p t·ª± nhi√™n khi kh√©p ng√≥n.
                // N·∫øu 30 v·∫´n kh√¥ng nh·∫≠n, h√£y th·ª≠ 35.
                return dist_tip_dip < 30; 
            };
            
            // 3.3. H√ÄM KI·ªÇM TRA ƒêI·ªÄU KI·ªÜN ƒê·∫∂C BI·ªÜT
            
            // Y√™u c·∫ßu M·ªöI: Ng√≥n tr·ªè v√† ng√≥n gi·ªØa ch·ªâ c·∫ßn DU·ªñI th·∫≥ng, KH√îNG c·∫ßn ki·ªÉm tra Kh√©p s√°t ch·∫∑t ch·∫Ω.
            const checkIndexMiddleProximity = () => {
                // Ch√∫ng ta ch·ªâ c·∫ßn ƒë·∫£m b·∫£o ch√∫ng kh√¥ng t√°ch qu√° xa m·ªôt c√°ch b·∫•t th∆∞·ªùng.
                // Trong tr∆∞·ªùng h·ª£p n√†y, ta s·∫Ω t·∫°m th·ªùi b·ªè qua h√†m n√†y (lu√¥n tr·∫£ v·ªÅ true) 
                // v√¨ y√™u c·∫ßu l√† "g·∫ßn song song" v√† kh√¥ng c·∫ßn "qu√° kh√©p l·∫°i"
                return true; 
            };
            
            // Ki·ªÉm tra ng√≥n c√°i Du·ªói v√† KH√îNG c·∫ßn Kh√©p s√°t ch·∫∑t ch·∫Ω
            const checkThumbAlignment = () => {
                const thumb_tip = landmarks[FINGER_LANDMARKS.THUMB_TIP];
                const thumb_mcp = landmarks[FINGER_LANDMARKS.THUMB_MCP];
                
                // 1. Ki·ªÉm tra ng√≥n c√°i du·ªói th·∫≥ng (s·ª≠ d·ª•ng t·ª∑ l·ªá ƒë·ªÉ du·ªói th·∫≥ng)
                const isThumbStraight = checkFingerStraight(FINGER_LANDMARKS.THUMB_TIP, FINGER_LANDMARKS.THUMB_IP, FINGER_LANDMARKS.THUMB_MCP);
                
                // 2. KH√îNG ki·ªÉm tra kho·∫£ng c√°ch kh√©p s√°t (lo·∫°i b·ªè dist_thumb_index_base < 60)
                // Ch·ªâ c·∫ßn n√≥ du·ªói th·∫≥ng l√† ƒë·ªß.
                return isThumbStraight;
            };

            // 3.4. T√çNH TO√ÅN TR·∫†NG TH√ÅI
            
            // Ng√≥n Tr·ªè & Gi·ªØa: Y√™u c·∫ßu DU·ªñI
            const isIndexUp = checkFingerStraight(FINGER_LANDMARKS.INDEX_FINGER_TIP, FINGER_LANDMARKS.INDEX_FINGER_PIP, FINGER_LANDMARKS.INDEX_FINGER_MCP);
            const isMiddleUp = checkFingerStraight(FINGER_LANDMARKS.MIDDLE_FINGER_TIP, FINGER_LANDMARKS.MIDDLE_FINGER_PIP, FINGER_LANDMARKS.MIDDLE_FINGER_MCP);
            
            // isIndexMiddleClosed (ch·ªâ ki·ªÉm tra du·ªói th·∫≥ng)
            const isIndexMiddleClosed = checkIndexMiddleProximity(); 

            // Ng√≥n C√°i: Y√™u c·∫ßu DU·ªñI (v√† kh√¥ng c·∫ßn kh√©p s√°t)
            const isThumbCorrect = checkThumbAlignment();
            
            // Ng√≥n √Åp √öt, √öt: Y√™u c·∫ßu G·∫¨P (ng∆∞·ª°ng 30)
            const isRingFolded = checkFingerFolded(FINGER_LANDMARKS.RING_FINGER_TIP, FINGER_LANDMARKS.RING_FINGER_DIP, FINGER_LANDMARKS.RING_FINGER_PIP);
            const isPinkyFolded = checkFingerFolded(FINGER_LANDMARKS.PINKY_FINGER_TIP, FINGER_LANDMARKS.PINKY_FINGER_DIP, FINGER_LANDMARKS.PINKY_FINGER_PIP);
            
            // T·ªîNG H·ª¢P: Ng√≥n c√°i DU·ªñI AND Tr·ªè DU·ªñI AND Gi·ªØa DU·ªñI AND √Åp √öt G·∫¨P AND √öt G·∫¨P
            // L∆∞u √Ω: isIndexMiddleClosed lu√¥n l√† true, ch·ªâ d√πng ƒë·ªÉ gi·ªØ c·∫•u tr√∫c.
            const allFingersCorrect = isThumbCorrect && isIndexUp && isMiddleUp && isIndexMiddleClosed && isRingFolded && isPinkyFolded;

            return {
                isCorrectHand: true,
                allFingersCorrect: allFingersCorrect,
                thumb: isThumbCorrect, 
                index: isIndexUp, // B·ªè isIndexMiddleClosed ·ªü ƒë√¢y
                middle: isMiddleUp, // B·ªè isIndexMiddleClosed ·ªü ƒë√¢y
                ring: isRingFolded,
                pinky: isPinkyFolded
            };
        }

        function handleSuccess() {
            window.isGestureSuccessful = true;
            
            overlayText.innerHTML = "QU√âT TH√ÄNH C√îNG!";
            overlayText.style.backgroundColor = 'rgba(76, 175, 80, 0.9)';
            
            statusMessage.textContent = " Nh·∫≠n d·∫°ng th√†nh c√¥ng! Ch√†o m·ª´ng ƒë·∫øn RvnSkr";
            statusMessage.classList.remove('status-processing');
            statusMessage.classList.add('status-success');
        }

        /**
         * H√†m v·∫Ω hitbox, nh·∫≠n ƒë·ªëi t∆∞·ª£ng tr·∫°ng th√°i ng√≥n tay ƒë·ªÉ ƒë·ªïi m√†u.
         */
        function drawHandLandmarks(landmarks, fingerStatus) {
            
            const DEFAULT_COLOR = '#FF4500'; // ƒê·ªè cam (Ch∆∞a ƒë√∫ng)
            const SUCCESS_COLOR = '#4CAF50'; // Xanh l√° (ƒê√£ ƒë√∫ng)
            const PALM_COLOR = '#808080'; // X√°m (L√≤ng b√†n tay)

            // L·∫•y m√†u cho c√°c ng√≥n tay
            const thumbColor = fingerStatus.thumb ? SUCCESS_COLOR : DEFAULT_COLOR;
            // Ch·ªâ ki·ªÉm tra Du·ªói (isIndexUp/isMiddleUp) ch·ª© kh√¥ng ki·ªÉm tra Kh√©p s√°t
            const indexColor = fingerStatus.index ? SUCCESS_COLOR : DEFAULT_COLOR; 
            const middleColor = fingerStatus.middle ? SUCCESS_COLOR : DEFAULT_COLOR;
            const ringColor = fingerStatus.ring ? SUCCESS_COLOR : DEFAULT_COLOR;
            const pinkyColor = fingerStatus.pinky ? SUCCESS_COLOR : DEFAULT_COLOR;

            // 1. V·∫Ω c√°c ƒëo·∫°n k·∫øt n·ªëi (x∆∞∆°ng)
            const segments = [
                { indices: FINGER_SEGMENTS.THUMB, color: thumbColor },
                { indices: FINGER_SEGMENTS.INDEX, color: indexColor },
                { indices: FINGER_SEGMENTS.MIDDLE, color: middleColor },
                { indices: FINGER_SEGMENTS.RING, color: ringColor },
                { indices: FINGER_SEGMENTS.PINKY, color: pinkyColor },
                { indices: FINGER_SEGMENTS.WRIST_PALM, color: PALM_COLOR }
            ];

            ctx.lineWidth = 3; 

            segments.forEach(segment => {
                ctx.strokeStyle = segment.color;
                segment.indices.forEach(([start, end]) => {
                    const p1 = landmarks[start];
                    const p2 = landmarks[end];
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });
            });

            // 2. V·∫Ω c√°c ƒëi·ªÉm m·ªëc (joints)
            landmarks.forEach((p, index) => {
                let color;
                
                if ([1, 2, 3, 4].includes(index)) { 
                    color = thumbColor;
                } else if ([5, 6, 7, 8].includes(index)) { 
                    color = indexColor;
                } else if ([9, 10, 11, 12].includes(index)) { 
                    color = middleColor;
                } else if ([13, 14, 15, 16].includes(index)) { 
                    color = ringColor;
                } else if ([17, 18, 19, 20].includes(index)) { 
                    color = pinkyColor;
                } else { 
                    color = PALM_COLOR;
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); 
                ctx.fill();
            });
        }

        // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
        setupDetector();
        
    </script>
</body>
</html>
