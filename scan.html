<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ki·ªÉm Tra C·ª≠ Ch·ªâ B√†n Tay Tr√°i (GitHub Pages)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script> 
    
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }
        #video-container {
            position: relative;
            width: 90%;
            max-width: 640px;
            margin-bottom: 20px;
            background-color: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        #video-feed, #canvas-output {
            width: 100%;
            height: auto;
            display: block;
            transform: scaleX(-1); /* L·∫≠t ngang ƒë·ªÉ t·∫°o c·∫£m gi√°c nh∆∞ g∆∞∆°ng */
        }
        #canvas-output {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #overlay-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.3em;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 8px;
            width: 90%;
            box-sizing: border-box;
            transition: all 0.5s ease;
            z-index: 10;
        }
        #status-message {
             margin-top: 10px;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.1em;
            width: 90%;
            max-width: 640px;
            text-align: center;
        }
        .status-initial { background-color: #3f51b5; color: white; }
        .status-processing { background-color: #ff9800; color: #333; }
        .status-success { background-color: #4CAF50; color: white; animation: pulse 1s infinite; }
        .status-error { background-color: #f44336; color: white; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="video-feed" autoplay playsinline></video>
        <canvas id="canvas-output"></canvas> 
        <div id="overlay-text">
            ‚åõ ƒêang t·∫£i m√¥ h√¨nh...
        </div>
    </div>

    <div id="status-message" class="status-initial">
        ƒêang ch·ªù quy·ªÅn truy c·∫≠p Camera v√† t·∫£i m√¥ h√¨nh H·ªçc m√°y. (Y√™u c·∫ßu HTTPS ho·∫∑c Localhost)
    </div>

    <script>
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('canvas-output');
        const ctx = canvas.getContext('2d');
        const overlayText = document.getElementById('overlay-text');
        const statusMessage = document.getElementById('status-message');
        
        let detector;
        let animationFrameId;
        window.isGestureSuccessful = false;

        // ƒêi·ªÉm m·ªëc quan tr·ªçng (theo MediaPipe)
        const FINGER_LANDMARKS = {
            WRIST: 0,
            THUMB_CMC: 1, THUMB_MCP: 2, THUMB_IP: 3, THUMB_TIP: 4,
            INDEX_FINGER_MCP: 5, INDEX_FINGER_PIP: 6, INDEX_FINGER_DIP: 7, INDEX_FINGER_TIP: 8,
            MIDDLE_FINGER_MCP: 9, MIDDLE_FINGER_PIP: 10, MIDDLE_FINGER_DIP: 11, MIDDLE_FINGER_TIP: 12,
            RING_FINGER_MCP: 13, RING_FINGER_PIP: 14, RING_FINGER_DIP: 15, RING_FINGER_TIP: 16,
            PINKY_MCP: 17, PINKY_FINGER_PIP: 18, PINKY_FINGER_DIP: 19, PINKY_FINGER_TIP: 20
        };

        // H√†m gi√∫p t√≠nh kho·∫£ng c√°ch gi·ªØa hai ƒëi·ªÉm trong kh√¥ng gian 3D
        function distance(p1, p2) {
            return Math.sqrt(
                Math.pow(p1.x - p2.x, 2) + 
                Math.pow(p1.y - p2.y, 2) + 
                Math.pow(p1.z - p2.z, 2)
            );
        }

        /**
         * 1. Thi·∫øt l·∫≠p Camera v√† T·∫£i m√¥ h√¨nh
         */
        async function setupDetector() {
            try {
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'mediapipe',
                    // S·ª≠ d·ª•ng ƒë∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi cho c√°c t·ªáp nh·ªã ph√¢n c·∫ßn thi·∫øt c·ªßa MediaPipe
                    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915', 
                    modelType: 'full'
                };
                detector = await handPoseDetection.createDetector(model, detectorConfig);

                overlayText.innerHTML = "‚úÖ M√¥ h√¨nh ƒë√£ t·∫£i. ƒêang xin quy·ªÅn Camera...";
                statusMessage.textContent = "‚úÖ M√¥ h√¨nh ƒë√£ t·∫£i. Vui l√≤ng c·∫•p quy·ªÅn Camera.";
                statusMessage.classList.remove('status-initial');
                statusMessage.classList.add('status-processing');
                
                await setupCamera();

            } catch (error) {
                console.error("L·ªói khi t·∫£i m√¥ h√¨nh ho·∫∑c camera:", error);
                statusMessage.textContent = `‚ùå L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh ho·∫∑c camera. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† quy·ªÅn camera.`;
                statusMessage.classList.remove('status-initial', 'status-processing');
                statusMessage.classList.add('status-error');
                overlayText.innerHTML = "‚ùå L·ªñI KH·ªûI T·∫†O";
            }
        }

        async function setupCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        // G√°n k√≠ch th∆∞·ªõc canvas theo k√≠ch th∆∞·ªõc th·ª±c c·ªßa video
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        startDetectionLoop();
                        resolve(true);
                    };
                });
            } else {
                throw new Error("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ MediaDevices API.");
            }
        }

        /**
         * 2. V√≤ng l·∫∑p Nh·∫≠n d·∫°ng C·ª≠ ch·ªâ (ƒê√£ s·ª≠a l·ªói T·ªça ƒë·ªô)
         */
        function startDetectionLoop() {
            const detect = async () => {
                // flipHorizontal: false v√¨ ch√∫ng ta ƒë√£ l·∫≠t b·∫±ng CSS (transform: scaleX(-1))
                const hands = await detector.estimateHands(video, { flipHorizontal: false }); 

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (hands.length > 0) {
                    const hand = hands[0];
                    
                    // H√†m ti·ªán √≠ch ƒë·ªÉ t√¨m t·ªça ƒë·ªô Z t·ª´ keypoints3D
                    const getZCoord = (id) => {
                        if (hand.keypoints3D && hand.keypoints3D[id]) {
                            // keypoints3D.z l√† t·ªça ƒë·ªô chu·∫©n h√≥a. Nh√¢n v·ªõi chi·ªÅu r·ªông canvas ƒë·ªÉ c√≥ gi√° tr·ªã t∆∞∆°ng ƒë·ªëi.
                            return hand.keypoints3D[id].z * canvas.width;
                        }
                        return 0;
                    };

                    // CHU·∫®N H√ìA T·ªåA ƒê·ªò
                    const landmarks = hand.keypoints.map((p, index) => {
                        return {
                            x: p.x * (canvas.width / video.videoWidth), 
                            y: p.y * (canvas.height / video.videoHeight), 
                            z: getZCoord(index), // L·∫•y t·ªça ƒë·ªô Z
                            name: p.name
                        };
                    });

                    // 3. TH·ª∞C HI·ªÜN LOGIC NH·∫¨N D·∫†NG C·ª¨ CH·ªà TR√ÅI
                    if (isTargetGesture(hand, landmarks)) {
                        handleSuccess();
                    } else {
                        drawHandLandmarks(landmarks);
                        // C·∫≠p nh·∫≠t th√¥ng b√°o
                        overlayText.innerHTML = `‚úã`;
                    }
                } else {
                    overlayText.innerHTML = "üëã";
                }

                if (!window.isGestureSuccessful) {
                    animationFrameId = requestAnimationFrame(detect);
                }
            };
            detect();
        }

        /**
         * 3. Logic Nh·∫≠n d·∫°ng C·ª≠ ch·ªâ M·ª•c ti√™u (ƒê√£ c·∫≠p nh·∫≠t Ng∆∞·ª°ng v√† S·ª≠a l·ªói L·∫≠t Camera)
         */
        function isTargetGesture(hand, landmarks) {
            
            // 3.1. KI·ªÇM TRA B√ÄN TAY TR√ÅI (Handedness - ƒê√É ƒê·∫¢O NG∆Ø·ª¢C LOGIC)
            // S·ª¨A L·ªñI: Ki·ªÉm tra 'Right' v√¨ camera tr∆∞·ªõc b·ªã l·∫≠t, tay tr√°i s·∫Ω ƒë∆∞·ª£c m√¥ h√¨nh nh·∫≠n di·ªán l√† tay ph·∫£i.
            if (hand.handedness !== 'Right') {
                return false; 
            }

            // 3.2. KI·ªÇM TRA TR·∫†NG TH√ÅI C√ÅC NG√ìN TAY 
            
            const checkFingerStraight = (tip_index, pip_index, mcp_index) => {
                const tip = landmarks[tip_index];
                const pip = landmarks[pip_index];
                const mcp = landmarks[mcp_index];

                const dist_tip_mcp = distance(tip, mcp);
                const dist_pip_mcp = distance(pip, mcp);
                
                // Ng∆∞·ª°ng: 1.25 (Gi·ªØ n·ªõi l·ªèng cho ng√≥n th·∫≥ng)
                return (dist_tip_mcp / dist_pip_mcp) > 1.25; 
            };

            const checkFingerFolded = (tip_index, dip_index, pip_index) => {
                const dist_tip_dip = distance(landmarks[tip_index], landmarks[dip_index]);
                
                // ƒêI·ªÄU CH·ªàNH: Gi·∫£m ng∆∞·ª°ng t·ª´ 65 xu·ªëng 40 ƒë·ªÉ y√™u c·∫ßu ng√≥n tay ph·∫£i g·∫≠p r√µ r√†ng, tr√°nh nh·∫≠n di·ªán nh·∫ßm khi tay m·ªü.
                return dist_tip_dip < 40; 
            };

            // Ng√≥n C√°i (Kh√°c bi·ªát): Th·∫≥ng n·∫øu TIP xa MCP.
            // ƒêI·ªÄU CH·ªàNH: TƒÉng t·ª´ 50 l√™n 65 ƒë·ªÉ y√™u c·∫ßu ng√≥n c√°i ph·∫£i du·ªói ra
            const isThumbUp = distance(landmarks[FINGER_LANDMARKS.THUMB_TIP], landmarks[FINGER_LANDMARKS.THUMB_MCP]) > 65; 

            // Ng√≥n Tr·ªè, Gi·ªØa GI∆† RA
            const isIndexUp = checkFingerStraight(FINGER_LANDMARKS.INDEX_FINGER_TIP, FINGER_LANDMARKS.INDEX_FINGER_PIP, FINGER_LANDMARKS.INDEX_FINGER_MCP);
            const isMiddleUp = checkFingerStraight(FINGER_LANDMARKS.MIDDLE_FINGER_TIP, FINGER_LANDMARKS.MIDDLE_FINGER_PIP, FINGER_LANDMARKS.MIDDLE_FINGER_MCP);

            // Ng√≥n √Åp √öt, √öt G·∫¨P L·∫†I
            const isRingFolded = checkFingerFolded(FINGER_LANDMARKS.RING_FINGER_TIP, FINGER_LANDMARKS.RING_FINGER_DIP, FINGER_LANDMARKS.RING_FINGER_PIP);
            const isPinkyFolded = checkFingerFolded(FINGER_LANDMARKS.PINKY_FINGER_TIP, FINGER_LANDMARKS.PINKY_FINGER_DIP, FINGER_LANDMARKS.PINKY_FINGER_PIP);
            
            // T·ªîNG H·ª¢P C·ª¨ CH·ªà (ƒê√£ b·ªè isPalmFacing)
            return isThumbUp && isIndexUp && isMiddleUp && isRingFolded && isPinkyFolded;
        }

        function handleSuccess() {
            window.isGestureSuccessful = true;
            cancelAnimationFrame(animationFrameId); 

            // C·∫≠p nh·∫≠t th√¥ng b√°o sau khi th√†nh c√¥ng
            overlayText.innerHTML = "QU√âT TH√ÄNH C√îNG!";
            overlayText.style.backgroundColor = 'rgba(76, 175, 80, 0.9)';
            
            statusMessage.textContent = " Nh·∫≠n d·∫°ng th√†nh c√¥ng! Ch√†o m·ª´ng ƒë·∫øn RvnSkr";
            statusMessage.classList.remove('status-processing');
            statusMessage.classList.add('status-success');
        }

        function drawHandLandmarks(landmarks) {
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], 
                [0, 5], [5, 6], [6, 7], [7, 8], 
                [9, 10], [10, 11], [11, 12], 
                [13, 14], [14, 15], [15, 16], 
                [0, 17], [17, 18], [18, 19], [19, 20], 
                [5, 9], [9, 13], [13, 17] 
            ];

            ctx.lineWidth = 2;
            ctx.strokeStyle = '#32CD32'; 
            ctx.fillStyle = '#FF4500'; 

            connections.forEach(([start, end]) => {
                const p1 = landmarks[start];
                const p2 = landmarks[end];
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });

            landmarks.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI); 
                ctx.fill();
            });
        }

        // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
        setupDetector();
        
    </script>
</body>
</html>
